From 1c78538f8486adb9a497ab46b8cdab2ee92bfbb9 Mon Sep 17 00:00:00 2001
From: "terry.wang" <dahua.wang@smartlinkmicro.com>
Date: Fri, 10 Nov 2023 03:30:55 +0000
Subject: [PATCH] add slm nfc chip support

---
 nxp/common.c  | 72 +++++++++++++++++++++++++++++++++++++++++++++++++++
 nxp/common.h  |  2 ++
 nxp/i2c_drv.c |  8 ++++--
 3 files changed, 80 insertions(+), 2 deletions(-)

diff --git a/nxp/common.c b/nxp/common.c
index 0a305b7..6d1f8d1 100755
--- a/nxp/common.c
+++ b/nxp/common.c
@@ -275,6 +275,14 @@ static int nfc_ioctl_power_states(struct nfc_dev *nfc_dev, unsigned long arg)
 		 */
 		set_valid_gpio(nfc_gpio->dwl_req, 0);
 		nfc_dev->nfc_state = NFC_STATE_NCI;
+	} else if (arg == NFC_SLM_DWL) {
+        nfc_dev->nfc_disable_intr(nfc_dev);
+        gpio_set_ven(nfc_dev, 1);
+        gpio_set_ven(nfc_dev, 0);
+        usleep_range(100000, 100100);
+        gpio_set_ven(nfc_dev, 1);
+        usleep_range(100000, 100100);
+        nfc_dev->nfc_enable_intr(nfc_dev);
 	} else {
 		pr_err("%s: bad arg %lu\n", __func__, arg);
 		ret = -ENOIOCTLCMD;
@@ -282,6 +290,70 @@ static int nfc_ioctl_power_states(struct nfc_dev *nfc_dev, unsigned long arg)
 	return ret;
 }
 
+int is_data_available_for_read(struct nfc_dev *nfc_dev)
+{
+    int ret;
+
+    nfc_dev->nfc_enable_intr(nfc_dev);
+
+    ret = wait_event_interruptible_timeout(nfc_dev->read_wq,
+                                           !nfc_dev->i2c_dev.irq_enabled,
+                                           msecs_to_jiffies(MAX_IRQ_WAIT_TIME));
+    return ret;
+}
+
+int nfcc_slm_hw_check(struct nfc_dev *nfc_dev)
+{
+    int ret = 0;
+    char private_cmd[10] = {'S', 'L', 'I', 'N', 'K', 0x0C, 0x00, 0x03, 0xBE, 0x00};
+    char private_rsp[12] = {0};
+    struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
+
+    if (nfc_dev->interface == PLATFORM_IF_I2C) {
+        gpio_set_value(nfc_gpio->dwl_req, 1);
+        gpio_set_ven(nfc_dev, 0);
+        gpio_set_ven(nfc_dev, 1);
+    }
+
+    do {
+        ret = nfc_dev->nfc_write(nfc_dev, private_cmd, sizeof(private_cmd), MAX_RETRY_COUNT);
+        if (ret <= 0) {
+            pr_err("%s: - slm private cmd write error ret %d\n",  __func__, ret);
+            ret = -ENXIO;
+            break;
+        }
+
+        if (nfc_dev->interface == PLATFORM_IF_I2C) {
+            ret = is_data_available_for_read(nfc_dev);
+            if (ret <= 0) {
+                nfc_dev->nfc_disable_intr(nfc_dev);
+                pr_err("%s: - error waiting for read rsp ret %d\n",  __func__, ret);
+                ret = -ENXIO;
+                break;
+            }
+        }
+
+        ret = nfc_dev->nfc_read(nfc_dev, private_rsp, sizeof(private_rsp), NCI_CMD_RSP_TIMEOUT_MS);
+        if (ret <= 0) {
+            pr_err("%s: - slm get rsp error ret %d\n", __func__, ret);
+            ret = -ENXIO;
+            break;
+        }
+
+        if (memcmp(private_cmd, private_rsp, 5) == 0) {
+            pr_info("%s slm chip check success!\n", __func__);
+            ret = 0;
+        }
+    } while(0);
+
+    if (nfc_dev->interface == PLATFORM_IF_I2C) {
+        gpio_set_value(nfc_gpio->dwl_req, 0);
+        gpio_set_ven(nfc_dev, 1);
+    }
+
+    return ret;
+}
+
 /**
  * nfc_dev_ioctl - used to set or get data from upper layer.
  * @pfile   file node for opened device.
diff --git a/nxp/common.h b/nxp/common.h
index 678177b..bf5beb7 100755
--- a/nxp/common.h
+++ b/nxp/common.h
@@ -103,6 +103,7 @@ enum nfcc_ioctl_request {
 	NFC_VEN_FORCED_HARD_RESET,
 	/* request for firmware download gpio LOW */
 	NFC_FW_DWL_LOW,
+	NFC_SLM_DWL = 100,
 };
 
 /* nfc platform interface type */
@@ -205,4 +206,5 @@ int configure_gpio(unsigned int gpio, int flag);
 void gpio_set_ven(struct nfc_dev *nfc_dev, int value);
 void gpio_free_all(struct nfc_dev *nfc_dev);
 int validate_nfc_state_nci(struct nfc_dev *nfc_dev);
+int nfcc_slm_hw_check(struct nfc_dev *nfc_dev);
 #endif /* _COMMON_H_ */
diff --git a/nxp/i2c_drv.c b/nxp/i2c_drv.c
index 350609e..1c10e4d 100755
--- a/nxp/i2c_drv.c
+++ b/nxp/i2c_drv.c
@@ -220,10 +220,13 @@ ssize_t nfc_i2c_dev_read(struct file *filp, char __user *buf, size_t count,
 {
 	int ret;
 	struct nfc_dev *nfc_dev = (struct nfc_dev *)filp->private_data;
+	struct platform_gpio *nfc_gpio = &nfc_dev->configs.gpio;
 
 	if (filp->f_flags & O_NONBLOCK) {
-		pr_err("%s: f_flags has nonblock. try again\n", __func__);
-		return -EAGAIN;
+		if (!gpio_get_value(nfc_gpio->irq)) {
+			pr_err("%s: f_flags has nonblock. try again\n", __func__);
+			return -EAGAIN;
+		}
 	}
 	mutex_lock(&nfc_dev->read_mutex);
 	ret = i2c_read(nfc_dev, nfc_dev->read_kbuf, count, 0);
@@ -363,6 +366,7 @@ int nfc_i2c_dev_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	i2c_set_clientdata(client, nfc_dev);
 	i2c_dev->irq_wake_up = false;
 
+	nfcc_slm_hw_check(nfc_dev);
 	pr_info("%s: probing nfc i2c successfully\n", __func__);
 	return 0;
 err_nfc_misc_unregister:
-- 
2.34.1

